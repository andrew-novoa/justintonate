<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Just Intonation Calculator</title>
    <link rel="icon" href="svgs/plus-minus-icon.png" type="image/x-icon">
    <link rel="stylesheet" href="styles.css">
    <script src="music_utils.js"></script>
</head>
<body>
    <div class="top-bar">
        <div class="header">
            <h1>Just Intonation Calculator</h1>
        </div>
        <div class="icon-tabs">
            <button class="help-button">?</button>
            <div class="icon-tab piano-icon active" id="pianoTab">ðŸŽ¹</div>
            <div class="icon-tab xy-icon" id="xyTab">X/Y</div>
            <div class="icon-tab phase-icon" id="phaseTab">
                <img src="svgs/two_sine.png" alt="Two Sine Waves" class="phase-icon-img">
            </div>
        </div>
    </div>
    <div id="piano-tab"class="tab-content">
        <div class="piano-functions">
            <div class="left-side-buttons">
                <button class="function-button deselect-button disabled">
                    <img src = "svgs/power.png" class="power-icon">
                </button>
                <button class="function-button mute-button disabled">
                    <img src = "svgs/Speaker_Icon.svg.png" class="audio-on-icon hidden">
                    <img src = "svgs/Mute_Icon.svg.png" class="mute-on-icon hidden">
                    <img src = "svgs/Speaker_Icon_Inactive.svg.png" class="audio-inactive-icon">
                </button>
                <button class="function-button rebalance-button disabled">
                    <img src = "svgs/unbalanced-scales.png" class="unbalanced-icon hidden">
                    <img src = "svgs/balanced-scales.png" class="balanced-icon">
                </button>
            </div>
            <div class="frequencyRatioString"></div>
            <div class="wavetable-buttons">
                <button class="function-button wavetable-button" data-wavetype="sine">
                    <img src="svgs/sine.png" class="sine-icon">
                </button>
                <button class="function-button wavetable-button" data-wavetype="square">
                    <img src="svgs/square.png" class="square-icon">
                </button>
                <button class="function-button wavetable-button" data-wavetype="sawtooth">
                    <img src="svgs/saw.png" class="saw-icon">
                </button>
            </div>
        </div>        
        <div id="piano-container" class="piano-container">
            <div class="piano">
                <div class="white-key" data-note="F3" data-enharmonic="F3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="F#3" data-enharmonic="Gb3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>       
                </div>
                <div class="white-key" data-note="G3" data-enharmonic="G3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="G#3" data-enharmonic="Ab3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>       
                </div>
                <div class="white-key" data-note="A3" data-enharmonic="A3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="A#3" data-enharmonic="Bb3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="B3" data-enharmonic="B3" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="C4" data-enharmonic="C4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="C#4" data-enharmonic="Db4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="D4" data-enharmonic="D4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="D#4" data-enharmonic="Eb4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="E4" data-enharmonic="E4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="F4" data-enharmonic="F4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="F#4" data-enharmonic="Gb4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="G4" data-enharmonic="G4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="G#4" data-enharmonic="Ab4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>       
                </div>
                <div class="white-key" data-note="A4" data-enharmonic="A4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="A#4" data-enharmonic="Bb4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="B4" data-enharmonic="B4" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="C5" data-enharmonic="C5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>        
                <div class="black-key" data-note="C#5" data-enharmonic="Db5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="D5" data-enharmonic="D5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="D#5" data-enharmonic="Eb5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="E5" data-enharmonic="E5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="F5" data-enharmonic="F5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="F#5" data-enharmonic="Gb5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="G5" data-enharmonic="G5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="G#5" data-enharmonic="Ab5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="A5" data-enharmonic="A5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="A#5" data-enharmonic="Bb5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="B5" data-enharmonic="B5" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="C6" data-enharmonic="C6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="C#6" data-enharmonic="Db6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="D6" data-enharmonic="D6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="D#6" data-enharmonic="Eb6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="E6" data-enharmonic="E6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="F6" data-enharmonic="F6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="black-key" data-note="F#6" data-enharmonic="Gb6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
                <div class="white-key" data-note="G6" data-enharmonic="G6" data-volume="1">
                    <div class="color-fill"></div>
                    <div class="key-label"></div>
                    <div class="adjustment"></div>
                    <div class="frequency"></div>
                </div>
            </div>
        </div>
    </div>
    <div id="xy-tab" class="tab-content">
        <div class="one-octave-piano">
            <div class="small-white-key" data-note="C" data-label="C">
                <div class="small-key-label">C</div>
            </div>
            <div class="small-black-key" data-note="C#" data-label="C# / Db">
                <div class="small-key-label">C# / Db</div>
            </div>
            <div class="small-white-key" data-note="D" data-label="D">
                <div class="small-key-label">D</div>
            </div>
            <div class="small-black-key" data-note="D#" data-label="D# / Eb">
                <div class="small-key-label">D# / Eb</div>
            </div>
            <div class="small-white-key" data-note="E" data-label="E">
                <div class="small-key-label">E</div>
            </div>
            <div class="small-white-key" data-note="F" data-label="F">
                <div class="small-key-label">F</div>
            </div>
            <div class="small-black-key" data-note="F#" data-label="F# / Gb">
                <div class="small-key-label">F# / Gb</div>
            </div>
            <div class="small-white-key" data-note="G" data-label="G">
                <div class="small-key-label">G</div>
            </div>
            <div class="small-black-key" data-note="G#" data-label="G# / Ab">
                <div class="small-key-label">G# / Ab</div>   
            </div>
            <div class="small-white-key" data-note="A" data-label="A">
                <div class="small-key-label">A</div>
            </div>
            <div class="small-black-key" data-note="A#" data-label="A# / Bb">
                <div class="small-key-label">A# / Bb</div>
            </div>
            <div class="small-white-key" data-note="B" data-label="B">
                <div class="small-key-label">B</div>
            </div>
        </div>
        <div class="tuning-adjustment"></div>
        <div class="melody-context">
            <button class="context-button" data-context="inside">Inside</button>
            <button class="context-button" data-context="outside">Outside</button>
        </div>
        <div class="chord-info">
            <button class="deselect-chord-button">Deselect Chord</button>
            <div class="chord-text">
                <div class="chord-symbol"></div>
                <div class="chord-pitches"></div>
            </div>
        </div>        
        <div class="chord-selector">
            <div class="row-label">Roots</div>
            <div class="row roots">
                <!-- Roots -->
                <button class="chord-btn" data-type="root" data-value="C">C</button>
                <button class="chord-btn" data-type="root" data-value="C#">C#/Db</button>
                <button class="chord-btn" data-type="root" data-value="D">D</button>
                <button class="chord-btn" data-type="root" data-value="D#">D#/Eb</button>
                <button class="chord-btn" data-type="root" data-value="E">E</button>
                <button class="chord-btn" data-type="root" data-value="F">F</button>
                <button class="chord-btn" data-type="root" data-value="F#">F#/Gb</button>
                <button class="chord-btn" data-type="root" data-value="G">G</button>
                <button class="chord-btn" data-type="root" data-value="G#">G#/Ab</button>
                <button class="chord-btn" data-type="root" data-value="A">A</button>
                <button class="chord-btn" data-type="root" data-value="A#">A#/Bb</button>
                <button class="chord-btn" data-type="root" data-value="B">B</button>
            </div>
            <div class="row-label">Qualities</div>
            <div class="row qualities">
                <!-- Qualities -->
                <button class="chord-btn" data-type="quality" data-value="major">Major</button>
                <button class="chord-btn" data-type="quality" data-value="minor">Minor</button>
                <button class="chord-btn" data-type="quality" data-value="augmented">Augmented</button>
                <button class="chord-btn" data-type="quality" data-value="diminished">Diminished</button>
                <button class="chord-btn" data-type="quality" data-value="power">Power</button>
                <button class="chord-btn" data-type="quality" data-value="sus2">sus2</button>
                <button class="chord-btn" data-type="quality" data-value="sus4">sus4</button>
            </div>
            <div class="row-label">Sevenths</div>
            <div class="row sevenths">
                <!-- Sevenths -->
                <button class="chord-btn" data-type="seventh" data-value="nat7">â™®7</button>
                <button class="chord-btn" data-type="seventh" data-value="m7">â™­7</button>
                <button class="chord-btn" data-type="seventh" data-value="bb7">â™­â™­7</button>
            </div>
            <div class="row-label">Extensions</div>
            <div class="row extensions">
                <!-- Extensions -->
                <button class="chord-btn" data-type="extension" data-value="add2">add2</button>
                <button class="chord-btn" data-type="extension" data-value="add4">add4</button>
                <button class="chord-btn" data-type="extension" data-value="add6">add6</button>
                <button class="chord-btn" data-type="extension" data-value="6/9">6/9</button>
                <button class="chord-btn" data-type="extension" data-value="9">9</button>
                <button class="chord-btn" data-type="extension" data-value="11">11</button>
                <button class="chord-btn" data-type="extension" data-value="13">13</button>
            </div>
            <div class="row-label">Alterations</div>
            <div class="row alterations">
                <!-- Alterations -->
                <button class="chord-btn" data-type="alteration" data-value="b5">b5</button>
                <button class="chord-btn" data-type="alteration" data-value="b6">b6</button>
                <button class="chord-btn" data-type="alteration" data-value="b9">b9</button>
                <button class="chord-btn" data-type="alteration" data-value="#9">#9</button>
                <button class="chord-btn" data-type="alteration" data-value="#11">#11</button>
                <button class="chord-btn" data-type="alteration" data-value="b13">b13</button>
                <button class="chord-btn" data-type="alteration" data-value="alt">alt</button>
            </div>
            <div class="row-label">Alternative Bass</div>
            <div class="row slash-roots">
                <!-- Slash Roots -->
                <button class="chord-btn" data-type="slash-root" data-value="/C">/C</button>
                <button class="chord-btn" data-type="slash-root" data-value="/C#">/C#</button>
                <button class="chord-btn" data-type="slash-root" data-value="/D">/D</button>
                <button class="chord-btn" data-type="slash-root" data-value="/D#">/D#</button>
                <button class="chord-btn" data-type="slash-root" data-value="/E">/E</button>
                <button class="chord-btn" data-type="slash-root" data-value="/F">/F</button>
                <button class="chord-btn" data-type="slash-root" data-value="/F#">/F#</button>
                <button class="chord-btn" data-type="slash-root" data-value="/G">/G</button>
                <button class="chord-btn" data-type="slash-root" data-value="/G#">/G#</button>
                <button class="chord-btn" data-type="slash-root" data-value="/A">/A</button>
                <button class="chord-btn" data-type="slash-root" data-value="/A#">/A#</button>
                <button class="chord-btn" data-type="slash-root" data-value="/B">/B</button>
            </div>
        </div>        
    </div>
    <div id="phase-tab" class="tab-content">
        <div class="phase-drag-area">
            <div class="phase-drag-buttons">
                <div class="phase-button-upper">
                    <div class="phase-chord-number-label">Number Of Notes</div>
                    <div class="phase-chord-number-buttons">
                        <button class="chord-number-button" data-type="minus">-</button>
                        <div class="phase-chord-number-display">2</div>
                        <button class="chord-number-button" data-type="plus">+</button>
                    </div>
                </div>
                <div class="phase-chord-type-label">Interval</div>
                <div class="phase-button-lower">
                    <div class="phase-chord-intervals">
                        <button class="phase-chord-preset" data-type="m2">m2</button>
                        <button class="phase-chord-preset" data-type="M2">M2</button>
                        <button class="phase-chord-preset" data-type="m3">m3</button>
                        <button class="phase-chord-preset" data-type="M3">M3</button>
                        <button class="phase-chord-preset" data-type="P4">P4</button>
                        <button class="phase-chord-preset" data-type="d5">d5</button>
                        <button class="phase-chord-preset active" data-type="P5">P5</button>
                        <button class="phase-chord-preset" data-type="m6">m6</button>
                        <button class="phase-chord-preset" data-type="M6">M6</button>
                        <button class="phase-chord-preset" data-type="m7">m7</button>
                        <button class="phase-chord-preset" data-type="M7">M7</button>
                        <button class="phase-chord-preset" data-type="P8">P8</button>
                    </div>
                    <div class="phase-chord-triads hidden">
                        <button class="phase-chord-preset active" data-type="major">Major</button>
                        <button class="phase-chord-preset" data-type="minor">Minor</button>
                        <button class="phase-chord-preset" data-type="augmented">Augmented</button>
                        <button class="phase-chord-preset" data-type="diminished">Diminished</button>
                    </div>
                    <div class="phase-chord-sevenths hidden">
                        <button class="phase-chord-preset active" data-type="major 7th">Major 7th</button>
                        <button class="phase-chord-preset" data-type="minor 7th">Minor 7th</button>
                        <button class="phase-chord-preset" data-type="dominant 7th">Dominant 7th</button>
                        <button class="phase-chord-preset" data-type="minor 7th flat five">Half Diminished</button>
                        <button class="phase-chord-preset" data-type="diminished 7th">Fully Diminished</button>
                    </div>
                </div>
            </div>
            <div class="phase-drag-lines">
                <img src="svgs/wholeNote.svg.png" class="note-drag" id="note-drag-1"></img>
                <img src="svgs/wholeNote.svg.png" class="note-drag" id="note-drag-2"></img>
                <img src="svgs/wholeNote.svg.png" class="note-drag" id="note-drag-3"></img>
                <img src="svgs/wholeNote.svg.png" class="note-drag" id="note-drag-4"></img>
                <div class="phase-drag-line" data-type="1200">+1200</div>
                <div class="phase-drag-line" data-type="1100">+1100</div>
                <div class="phase-drag-line" data-type="1000">+1000</div>
                <div class="phase-drag-line" data-type="900">+900</div>
                <div class="phase-drag-line" data-type="800">+800</div>
                <div class="phase-drag-line" data-type="700">+700</div>
                <div class="phase-drag-line" data-type="600">+600</div>
                <div class="phase-drag-line" data-type="500">+500</div>
                <div class="phase-drag-line" data-type="400">+400</div>
                <div class="phase-drag-line" data-type="300">+300</div>
                <div class="phase-drag-line" data-type="200">+200</div>
                <div class="phase-drag-line" data-type="100">+100</div>
                <div class="phase-drag-line" data-type="0">+0</div>
            </div>
        </div>
        <div class="phase-graph-area">
            <div class="phase-graph-info">
                <div class="ratio-display-div">
                    <div class="ratio-display-label">Ratio</div>
                    <div class="ratio-display"></div>
                </div>
                <div class="cancellation-display-div">
                    <div class="cancellation-display-label">Cancellations</div>
                    <div class="cancellation-display"></div>
                </div>
            </div>
            <div class="canvas-graph">
                <canvas id="canvas"></canvas>
            </div>
            <!-- <div class="canvas-option-div hidden">
                <button class="canvas-option active" data-type="multi">Multi</button>
                <button class="canvas-option" data-type="summed">Summed</button>
            </div>
            <div class="canvas-volume-div hidden">
                <div class="canvas-volume-label">Volume</div>
                <div class="canvas-volume-options">
                    <div class="canvas-volume-option">
                        <input type="range" min="0" max="100" value="100" class="canvas-volume-slider" data-type="sine-1">
                        <button class="canvas-volume-button" data-type="mute-1">
                            <img src="svgs/Speaker_Icon.svg.png" class="audio-on-icon">
                        </button>
                    </div>
                    <div class="canvas-volume-option">
                        <input type="range" min="0" max="100" value="100" class="canvas-volume-slider" data-type="sine-2">
                        <button class="canvas-volume-button" data-type="mute-2">
                            <img src="svgs/Speaker_Icon.svg.png" class="audio-on-icon">
                        </button>
                    </div>
                    <div class="canvas-volume-option">
                        <input type="range" min="0" max="100" value="100" class="canvas-volume-slider" data-type="sine-3">
                        <button class="canvas-volume-button" data-type="mute-3">
                            <img src="svgs/Speaker_Icon.svg.png" class="audio-on-icon">
                        </button>
                    </div>
                    <div class="canvas-volume-option">
                        <input type="range" min="0" max="100" value="100" class="canvas-volume-slider" data-type="sine-4">
                        <button class="canvas-volume-button" data-type="mute-4">
                            <img src="svgs/Speaker_Icon.svg.png" class="audio-on-icon">
                        </button>
                    </div>
                </div>
            </div> -->
        </div>
    </div>
    <script>
        
        window.addEventListener('load', () => {
            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
            const masterGainNode = audioContext.createGain();
            masterGainNode.connect(audioContext.destination);
            const activeOscillators = {};
            const activeGainNodes = {};
            let currentWavetype = 'sine'; // Default wavetable type
            let gainScale = 0.2
            if (currentWavetype !== 'sine') {
                gainScale = 0.15
            } else {
                gainScale = 0.2
            }

            // Function to start an oscillator and its corresponding gain node
            function startOscillator(freq, note, volumeAdjustment) {
                const oscillator = audioContext.createOscillator();
                oscillator.type = currentWavetype;
                oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
                
                const gainNode = audioContext.createGain();
                gainNode.gain.value = gainScale * volumeAdjustment; // Reduce the gain to 20%
                
                oscillator.connect(gainNode);
                gainNode.connect(masterGainNode);
                
                oscillator.start();
                
                activeOscillators[note] = oscillator;
                activeGainNodes[note] = gainNode;  // Store the gain node
            }

            // Function to stop an oscillator and its corresponding gain node
            function stopOscillator(note, fadeOutDuration = 0.02) { // Default fade-out duration is 5 seconds
                if (activeOscillators[note]) {
                    // Set the current gain value to start the ramp
                    activeGainNodes[note].gain.setValueAtTime(activeGainNodes[note].gain.value, audioContext.currentTime);
                    
                    // Ramp down to 0 over fadeOutDuration seconds
                    activeGainNodes[note].gain.linearRampToValueAtTime(0, audioContext.currentTime + fadeOutDuration);

                    // Stop the oscillator after fadeOutDuration seconds to allow the fade-out to complete
                    activeOscillators[note].stop(audioContext.currentTime + fadeOutDuration);

                    // Schedule the removal of the oscillator and gain node after the fade-out
                    setTimeout(() => {
                        delete activeOscillators[note];
                        delete activeGainNodes[note];  // Remove the gain node
                        checkAndResetMute();
                    }, fadeOutDuration * 1000);  // Convert fadeOutDuration to milliseconds
                }
            }

            // Function to change the frequency and volume of active oscillators
            function changeFrequencyAndVolume(note, newFreq, newVolumeAdjustment) {
                if (activeOscillators[note]) {
                    activeOscillators[note].frequency.setValueAtTime(newFreq, audioContext.currentTime);

                    activeGainNodes[note].gain.setValueAtTime(activeGainNodes[note].gain.value, audioContext.currentTime);
                    activeGainNodes[note].gain.linearRampToValueAtTime(gainScale * newVolumeAdjustment, audioContext.currentTime + 0.02);

                    updateColorFill(document.querySelector(`[data-note="${note}"]`), newVolumeAdjustment);
                }
            }

            function updateColorFill(keyElement, volumeLevel) {
                const colorFillElement = keyElement.querySelector('.color-fill');
                const keyLabelElement = keyElement.querySelector('.key-label');
                const newHeight = `${Math.max(volumeLevel, 0.1) * 100}%`; // Minimum 10% fill

                colorFillElement.style.height = newHeight;

                // Check if the fill is below 10%
                if (Math.max(volumeLevel, 0.1) * 100 < 17) {
                    keyLabelElement.classList.add('low-fill');
                } else {
                    keyLabelElement.classList.remove('low-fill');
                }
            }

            function removeColorFill(keyElement) {
                const colorFillElement = keyElement.querySelector('.color-fill');
                colorFillElement.style.height = "0%";
            }

            const bigPianokeys = document.querySelectorAll('.white-key, .black-key');
            const freqRatioDiv = document.querySelector('.frequencyRatioString');
            let activePitches = [];
            let prevTouchY = null;
            let currentKey = null; // To keep track of the current key being dragged
            let isDragging = false;
            let wasDragged = false;
            let initialVolume = 0;
            let lastCalledTime = 0;
            let startMouseY = null; // Track starting mouse position
            let startTouchY = null; // Track starting touch position
            const delay = 16; // 60fps
            const dragThreshold = 3; // Minimum pixels to move before considering it a drag

            function handlePianoStart(event) {
                isDragging = true;
                wasDragged = false; // Reset wasDragged at start
                currentKey = this; // Set the current key
                initialVolume = parseFloat(this.getAttribute('data-volume') || '0.1');
                // Record starting position
                if (event.type === 'mousedown') {
                    startMouseY = event.clientY;
                } else if (event.type === 'touchstart') {
                    startTouchY = event.touches[0].clientY;
                }
            }

            function handlePianoMove(event) {
                const currentTime = new Date().getTime();
                if (currentTime - lastCalledTime < delay) {
                    return;
                }
                lastCalledTime = currentTime;
                if (isDragging && currentKey && currentKey.classList.contains('active')) {
                    let deltaY;
                    let totalMovement = 0;

                    if (event.type === 'mousemove') {
                        deltaY = event.movementY;
                        // Calculate total movement from start position
                        if (startMouseY !== null) {
                            totalMovement = Math.abs(event.clientY - startMouseY);
                        }
                    } else if (event.type === 'touchmove') {
                        const currentTouchY = event.touches[0].clientY;
                        if (prevTouchY !== null) {
                            deltaY = Math.round(currentTouchY - prevTouchY);
                        } else {
                            deltaY = 0;
                        }
                        prevTouchY = currentTouchY;
                        // Calculate total movement from start position
                        if (startTouchY !== null) {
                            totalMovement = Math.abs(currentTouchY - startTouchY);
                        }
                    }
                    
                    // Only set wasDragged if we've moved significantly from the start position
                    // This prevents tiny movements during clicks from being treated as drags
                    if (totalMovement > dragThreshold) {
                        wasDragged = true;
                        event.preventDefault(); // Prevent default behavior like scrolling
                    }
                    
                    let newVolume = initialVolume - deltaY * 0.01; // Adjust the sensitivity here
                    newVolume = Math.min(Math.max(newVolume, 0.1), 1); // Clamp between 0.1 and 1

                    currentKey.setAttribute('data-volume', newVolume);
                    currentKey.classList.add('manual');
                    document.querySelector('.balanced-icon').classList.add('hidden');
                    document.querySelector('.unbalanced-icon').classList.remove('hidden');
                    rebalanceButton.classList.remove('active');
                    updateColorFill(currentKey, newVolume); // Your function to update color fill

                    // Update the gain value in your audio code
                    const note = currentKey.getAttribute('data-note');
                    if (activeGainNodes[note]) {
                        // activeGainNodes[note].gain.value = gainScale * newVolume;
                        activeGainNodes[note].gain.setValueAtTime(activeGainNodes[note].gain.value, audioContext.currentTime);
                        activeGainNodes[note].gain.linearRampToValueAtTime(gainScale * newVolume, audioContext.currentTime + 0.02);
                    }

                    initialVolume = newVolume;
                }
            }

            function handlePianoEnd(event) {
                // Reset touch position for touch events
                if (event.type === 'touchend') {
                    prevTouchY = null;
                    startTouchY = null;
                }
                // Reset mouse position tracking
                if (event.type === 'mouseup') {
                    startMouseY = null;
                }
                // Reset dragging state
                isDragging = false;
                currentKey = null; // Reset the current key
                // Note: wasDragged is checked in the click handler and reset there if needed
                // This ensures click events can properly check if a drag occurred
            }

            bigPianokeys.forEach(key => {
                const noteLabel = key.getAttribute('data-note');
                const enharmonicLabel = key.getAttribute('data-enharmonic');
                if (enharmonicLabel !== noteLabel) {
                    key.querySelector('.key-label').textContent = `${noteLabel} ${enharmonicLabel}`;
                } else {
                key.querySelector('.key-label').textContent = noteLabel;
                }

                key.addEventListener('mousedown', handlePianoStart);
                key.addEventListener('touchstart', handlePianoStart, { passive: false });

                key.addEventListener('click', function(event) {
                    const note = this.getAttribute('data-note');
                    const freqDiv = this.querySelector('.frequency');
                    let volumeAdjustment = parseFloat(this.getAttribute('data-volume') || '0.1');

                    // Check if this was a drag operation - if so, ignore the click
                    // wasDragged is set to true in handlePianoMove only when dragging an active key
                    if (wasDragged) {
                        wasDragged = false; // Reset the flag
                        return; // If the key was dragged, don't toggle the active state
                    }
                    
                    // Small delay to ensure wasDragged is properly checked after mouseup
                    // This handles cases where mousemove might have been triggered by tiny movements
                    if (isDragging === false) {
                        // If we're not dragging, it's a legitimate click
                    }
                    
                    if (this.classList.contains('active')) {
                        stopOscillator(note);
                        removeColorFill(this);
                        const index = activePitches.indexOf(note);
                        activePitches.splice(index, 1);
                        this.querySelector('.frequency').textContent = "";
                        this.querySelector('.adjustment').textContent = "";
                        this.classList.remove('active');
                        this.classList.remove('manual');
                    } else if (activePitches.length < 8) {
                        if (muteButton.classList.contains('disabled')) {
                            muteButton.classList.remove('disabled');
                            document.querySelector('.audio-inactive-icon').classList.add('hidden');
                            document.querySelector('.audio-on-icon').classList.remove('hidden');
                        }
                        if (document.querySelector('.mute-on-icon').classList.contains('hidden') && !muteButton.classList.contains('active')) {
                            muteButton.classList.add('active');
                        }
                        if (document.querySelector('.audio-on-icon').classList.contains('hidden') && muteButton.classList.contains('active')) {
                            muteButton.classList.remove('active');
                        }
                        activePitches.push(note);
                        this.classList.add('active');
                    }

                    if (activePitches.length > 0 && pianoTabIcon.classList.contains('active')) {
                        deselectButton.classList.remove('disabled');
                        deselectButton.classList.add('active');
                        rebalanceButton.classList.remove('disabled');
                        rebalanceButton.classList.add('active');
                        try {
                            const [justIntonationData, freqRatioString] = just_intonate(activePitches);
                        
                        Object.entries(justIntonationData).forEach(([pitch, info]) => {
                            const keyElement = document.querySelector(`[data-note="${pitch}"]`);
                            const freqDiv = keyElement.querySelector('.frequency');
                            const adjustmentDiv = keyElement.querySelector('.adjustment');

                            freqDiv.textContent = info[0];
                            adjustmentDiv.textContent = info[1];
                            volumeAdjustment = keyElement.getAttribute('data-volume');

                            // Check if pitch is not in activePitches
                            if (!keyElement.classList.contains('manual')) {
                                volumeAdjustment = info[2];
                                keyElement.setAttribute('data-volume', volumeAdjustment.toString());
                            } else {
                                rebalanceButton.classList.remove('active');
                            }

                            // Update the frequency and volume of the active oscillator
                            const newFreq = parseFloat(info[0].split(' ')[0]);
                            changeFrequencyAndVolume(pitch, newFreq, volumeAdjustment);
                            
                        });

                        freqRatioDiv.textContent = freqRatioString;
                        } catch (error) {
                            console.error('Error:', error);
                        }
                    }

                    if (freqDiv.textContent) {
                        const freq = parseFloat(freqDiv.textContent.split(' ')[0]);
                        const noteVolume = parseFloat(this.getAttribute('data-volume') || '0.1')
                        startOscillator(freq, note, noteVolume);
                        updateColorFill(this, noteVolume);
                    }

                    if (chordDisplay.textContent && xyTabIcon.classList.contains('active')) {
                        updateAdjustmentInfo(note);
                    }
                });
            });

            document.addEventListener('mousemove', handlePianoMove);
            document.addEventListener('touchmove', handlePianoMove, { passive: false });

            document.addEventListener('mouseup', handlePianoEnd);
            document.addEventListener('touchend', handlePianoEnd);

            // Get the deselect button element
            const deselectButton = document.querySelector('.deselect-button');

            // Add click event listener to the deselect button
            deselectButton.addEventListener('click', function() {
                // Loop through all active piano keys and deactivate them
                bigPianokeys.forEach(key => {
                    if (key.classList.contains('active')) {
                        const note = key.getAttribute('data-note');
                        stopOscillator(note);
                        removeColorFill(key);
                        key.querySelector('.frequency').textContent = "";
                        key.querySelector('.adjustment').textContent = "";
                        key.setAttribute('data-volume', '1');
                        key.classList.remove('manual');
                        key.classList.remove('active');
                    }
                });

                // Clear the activePitches array
                activePitches = [];

                // Clear the frequency ratio string
                freqRatioDiv.textContent = "";
                deselectButton.classList.add('disabled');
            });

            const rebalanceButton = document.querySelector('.rebalance-button');

            rebalanceButton.addEventListener('click', () => {
                if (activePitches.length > 0 && pianoTabIcon.classList.contains('active')) {
                    try {
                        const [justIntonationData, freqRatioString] = just_intonate(activePitches);
                        
                        Object.entries(justIntonationData).forEach(([pitch, info]) => {
                            const keyElement = document.querySelector(`[data-note="${pitch}"]`);
                            const freqDiv = keyElement.querySelector('.frequency');

                            volumeAdjustment = info[2];
                            keyElement.setAttribute('data-volume', volumeAdjustment.toString());
                            keyElement.classList.remove('manual');

                            // Update the frequency and volume of the active oscillator
                            const newFreq = parseFloat(info[0].split(' ')[0]);
                            changeFrequencyAndVolume(pitch, newFreq, volumeAdjustment);
                        });
                    } catch (error) {
                        console.error('Error:', error);
                    }
                }
                document.querySelector('.balanced-icon').classList.remove('hidden');
                document.querySelector('.unbalanced-icon').classList.add('hidden');
                rebalanceButton.classList.add('active');
            });

            let isMuted = false;  // A flag to keep track of the mute state
            const muteButton = document.querySelector('.mute-button');

            muteButton.addEventListener('click', () => {
                if (isMuted) {
                    masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);  // Unmute
                    masterGainNode.gain.linearRampToValueAtTime(1, audioContext.currentTime + 0.01);
                    if (!document.querySelector('.mute-on-icon').classList.contains('hidden')) {
                        document.querySelector('.mute-on-icon').classList.add('hidden');
                    }
                    document.querySelector('.audio-on-icon').classList.remove('hidden');
                    muteButton.classList.add('active');
                } else {
                    masterGainNode.gain.setValueAtTime(1, audioContext.currentTime);
                    masterGainNode.gain.linearRampToValueAtTime(0, audioContext.currentTime + 0.01);  // Mute
                    if (!document.querySelector('.audio-on-icon').classList.contains('hidden')) {
                        document.querySelector('.audio-on-icon').classList.add('hidden');
                    }
                    document.querySelector('.mute-on-icon').classList.remove('hidden');
                    muteButton.classList.remove('active');
                }
                isMuted = !isMuted;
            });

            // Reset the mute button when all keys are turned off
            function checkAndResetMute() {
                const hasActiveOscillators = Object.keys(activeOscillators).length > 0;

                // Common actions for both conditions
                function resetIconsAndButtons() {
                    document.querySelector('.mute-on-icon').classList.add('hidden');
                    document.querySelector('.audio-on-icon').classList.add('hidden');
                    document.querySelector('.audio-inactive-icon').classList.remove('hidden');
                    muteButton.classList.remove('active');
                    deselectButton.classList.add('disabled');
                    deselectButton.classList.remove('active');
                    rebalanceButton.classList.add('disabled');
                    rebalanceButton.classList.remove('active');

                    if (document.querySelector('.balanced-icon').classList.contains('hidden')) {
                        document.querySelector('.balanced-icon').classList.remove('hidden');
                        document.querySelector('.unbalanced-icon').classList.add('hidden');
                    }
                }

                if (!hasActiveOscillators && isMuted) {
                    masterGainNode.gain.setValueAtTime(1, audioContext.currentTime);  // Unmute
                    muteButton.classList.remove('active');
                    muteButton.classList.add('disabled');
                    isMuted = false;
                    resetIconsAndButtons();
                } else if (!hasActiveOscillators) {
                    muteButton.classList.add('disabled');
                    resetIconsAndButtons();
                }
            }

            // Get all wavetable buttons
            const wavetableButtons = document.querySelectorAll('.wavetable-button');
            document.querySelector('.wavetable-button[data-wavetype="sine"]').classList.add('active');

            // Add click event listener to each wavetable button
            wavetableButtons.forEach(button => {
                button.addEventListener('click', function() {
                    // Remove active class from all buttons
                    wavetableButtons.forEach(btn => btn.classList.remove('active'));

                    // Add active class to clicked button
                    this.classList.add('active');

                    // Update current wavetable type
                    currentWavetype = this.getAttribute('data-wavetype');

                    // Update the wavetype of all active oscillators
                    for (const note in activeOscillators) {
                        if (currentWavetype !== 'sine') {
                            gainScale = 0.15
                        } else {
                            gainScale = 0.2
                        }
                        activeGainNodes[note].gain.value = gainScale * parseFloat(document.querySelector(`[data-note="${note}"]`).getAttribute('data-volume') || '0.1');
                        activeOscillators[note].type = currentWavetype;
                    }
                });
            });

            function clearPianoScreen() {
                // Check if bigPianokeys is defined
                if (typeof bigPianokeys !== 'undefined' && bigPianokeys) {
                    // Loop through all active piano keys and deactivate them
                    bigPianokeys.forEach(key => {
                        if (key.classList.contains('active')) {
                            const note = key.getAttribute('data-note');
                            if (typeof stopOscillator === 'function') {
                                stopOscillator(note);
                            }
                            if (typeof removeColorFill === 'function') {
                                removeColorFill(key);
                            }
                            const freqDiv = key.querySelector('.frequency');
                            const adjDiv = key.querySelector('.adjustment');
                            if (freqDiv) freqDiv.textContent = "";
                            if (adjDiv) adjDiv.textContent = "";
                            key.classList.remove('active');
                        }
                    });
                }

                // Clear the activePitches array
                if (typeof activePitches !== 'undefined') {
                    activePitches = [];
                }

                // Clear the frequency ratio string
                if (typeof freqRatioDiv !== 'undefined' && freqRatioDiv) {
                    freqRatioDiv.textContent = "";
                }
            }

            // Tab functionality
            const pianoTabIcon = document.getElementById('pianoTab');
            const xyTabIcon = document.getElementById('xyTab');
            const phaseTabIcon = document.getElementById('phaseTab');
            const pianoContent = document.getElementById('piano-tab');
            const xyContent = document.getElementById('xy-tab');
            const phaseContent = document.getElementById('phase-tab');

            // Set initial display states
            pianoContent.style.display = 'block';
            xyContent.style.display = 'none';
            phaseContent.style.display = 'none';

            // Store references to phase tab event handlers for cleanup
            let phaseDragEndHandler = null;
            let phaseDragHandler = null;
            let phaseScrollHandler = null;

            pianoTabIcon.addEventListener('click', function() {
                // Check which tabs were active before removing the classes
                const wasXYActive = xyTabIcon.classList.contains('active');
                const wasPhaseActive = phaseTabIcon.classList.contains('active');
                pianoTabIcon.classList.add('active');
                xyTabIcon.classList.remove('active');
                phaseTabIcon.classList.remove('active');
                // Only clear screens if they were visible
                if (wasXYActive) {
                    clearXYscreen();
                }
                if (wasPhaseActive) {
                    clearPhaseScreen();
                }
                pianoContent.style.display = 'block';
                xyContent.style.display = 'none';
                phaseContent.style.display = 'none';
            });

            xyTabIcon.addEventListener('click', function() {
                try {
                    // Check which tabs were active before removing the classes
                    const wasPianoActive = pianoTabIcon.classList.contains('active');
                    const wasPhaseActive = phaseTabIcon.classList.contains('active');
                    
                    xyTabIcon.classList.add('active');
                    pianoTabIcon.classList.remove('active');
                    phaseTabIcon.classList.remove('active');
                    
                    // Set display first to ensure content is available
                    pianoContent.style.display = 'none';
                    xyContent.style.display = 'block';
                    phaseContent.style.display = 'none';
                    
                    // Only clear screens if they were visible
                    if (wasPianoActive && typeof clearPianoScreen === 'function') {
                        clearPianoScreen();
                    }
                    if (wasPhaseActive && typeof clearPhaseScreen === 'function') {
                        clearPhaseScreen();
                    }
                } catch (error) {
                    console.error('Error switching to X/Y tab:', error);
                    // Still try to show the tab even if there's an error
                    xyContent.style.display = 'block';
                    pianoContent.style.display = 'none';
                    phaseContent.style.display = 'none';
                }
            });

            phaseTabIcon.addEventListener('click', function() {
                // Remove early return - allow re-initialization
                phaseTabIcon.classList.add('active');
                xyTabIcon.classList.remove('active');
                pianoTabIcon.classList.remove('active');
                clearPianoScreen();
                clearXYscreen();
                pianoContent.style.display = 'none';
                xyContent.style.display = 'none';
                phaseContent.style.display = 'block';
                
                // Remove existing event listeners before adding new ones
                if (phaseDragEndHandler) {
                    document.removeEventListener('mouseup', phaseDragEndHandler);
                    document.removeEventListener('touchend', phaseDragEndHandler);
                }
                if (phaseDragHandler) {
                    document.removeEventListener('mousemove', phaseDragHandler);
                    document.removeEventListener('touchmove', phaseDragHandler);
                }
                if (phaseScrollHandler) {
                    document.removeEventListener('scrollend', phaseScrollHandler);
                }
                
                calculateLinePositions();
                storeOriginalPositions();
                
                // Re-query dragItems to get fresh references and remove old listeners
                const currentDragItems = document.querySelectorAll('.note-drag');
                currentDragItems.forEach(dragItem => {
                    // note-drag-1 has pointer-events: none in CSS, so skip it
                    if (dragItem.id !== 'note-drag-1') {
                        // Remove old listeners by cloning (this removes all event listeners)
                        const parent = dragItem.parentNode;
                        const dragItemId = dragItem.id;
                        const newDragItem = dragItem.cloneNode(true);
                        parent.replaceChild(newDragItem, dragItem);
                        
                        // Re-select the element after replacement
                        const updatedDragItem = document.getElementById(dragItemId);
                        if (updatedDragItem) {
                            // Add event listeners for dragging
                            updatedDragItem.addEventListener('mousedown', dragStart);
                            updatedDragItem.addEventListener('touchstart', dragStart, { passive: false });
                            if (updatedDragItem.id === 'note-drag-3' || updatedDragItem.id === 'note-drag-4') {
                                updatedDragItem.classList.add('hidden');
                            }
                        }
                    }
                });
                
                // Update dragItems array with new references after cloning
                dragItems = document.querySelectorAll('.note-drag');
                
                // Store handlers for cleanup
                phaseDragEndHandler = dragEnd;
                phaseDragHandler = drag;
                phaseScrollHandler = () => {
                    calculateLinePositions();
                    getAllPositionValues(); // Update positions after scrolling
                };
                
                document.addEventListener('mouseup', phaseDragEndHandler);
                document.addEventListener('mousemove', phaseDragHandler);
                document.addEventListener('touchend', phaseDragEndHandler);
                document.addEventListener('touchmove', phaseDragHandler, { passive: false });

                phaseNoteNumber = document.querySelectorAll('.note-drag:not(.hidden)').length;
                if (phaseChordNumberDisplay) {
                    phaseChordNumberDisplay.textContent = phaseNoteNumber;
                }
                updateNoteNumberButtons(phaseNoteNumber);
                updatePresets(phaseNoteNumber);
                getAllPositionValues();
                var cancellations = calculatePhaseCancellation(allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                setCancellationDisplay(cancellations);
                
                document.addEventListener('scrollend', phaseScrollHandler);
            });

            // Chord selector
            // Define and initialize the variables
            let selectedRoot = null;
            let selectedQuality = null;
            let selectedSeventh = null;
            let selectedExtension = null;
            let selectedAlteration = null;
            let selectedSlash = null;

            const enharmonicMap = {
                        "C#": "Db",
                        "D#": "Eb",
                        "F#": "Gb",
                        "G#": "Ab",
                        "A#": "Bb"
                    };

            const reverseEnharmonicMap = {};
                for (const [sharp, flat] of Object.entries(enharmonicMap)) {
                    reverseEnharmonicMap[flat] = sharp;
            };

            const adjustmentInfo = document.querySelector('.tuning-adjustment');
            const chordDisplay = document.querySelector('.chord-symbol');
            const chordPitches = document.querySelector('.chord-pitches');
            let melodyContext = "inside"
            let insidePossible = true;
            let outsidePossible = true;
            let chordPitchesList = [];

            const smallPianokeys = document.querySelectorAll('.small-white-key, .small-black-key');

            smallPianokeys.forEach(smallKey => {
                smallKey.addEventListener('click', function() {
                    const wasActive = this.classList.contains('active'); // Check if the clicked key was active

                    // Remove 'active' class from all keys
                    smallPianokeys.forEach(key => {
                        key.classList.remove('active');
                    });

                    // If the clicked key was not previously active, add the 'active' class
                    if (!wasActive) {
                        this.classList.add('active');
                    }

                    if (chordDisplay.textContent && this.classList.contains('active')) {
                        // Enable context buttons when there is a chord symbol and an active key
                        contextButtons.forEach(button => {
                            button.classList.remove('disabled');
                        });

                        const note = this.getAttribute('data-note');
                        updateAdjustmentInfo(note, melodyContext);
                    } else {
                        adjustmentInfo.textContent = "";
                        // Disable context buttons when there is no chord symbol or active key
                        contextButtons.forEach(button => {
                            button.classList.add('disabled');
                            button.classList.remove('selected');
                        });
                    }
                });
            });

            // Function to update labels based on window width
            function updateLabels() {
                const windowWidth = window.innerWidth;
                const blackKeys = document.querySelectorAll('.small-black-key');

                blackKeys.forEach((key) => {
                    const labelElement = key.querySelector('.small-key-label');
                    const fullLabel = key.getAttribute('data-label');
                    const shortLabel = fullLabel.split(' ')[0]; // Get the first part of the label (e.g., "C#")

                    if (windowWidth < 600) {
                        labelElement.textContent = shortLabel;
                    } else {
                        labelElement.textContent = fullLabel;
                    }
                });
            }

            // Update labels initially
            updateLabels();

            // Listen for window resize events
            window.addEventListener('resize', updateLabels);


            // Event listeners for context-buttons
            const contextButtons = document.querySelectorAll('.context-button');
            contextButtons.forEach(button => {
                button.classList.add('disabled');
                button.classList.remove('selected');
                button.addEventListener('click', function() {
                    // Check if the button is disabled
                    if (this.classList.contains('disabled')) {
                        return;
                    }

                    // Remove 'selected' class from all context-buttons
                    contextButtons.forEach(btn => {
                        btn.classList.remove('selected');
                    });

                    // Add 'selected' class to clicked button
                    this.classList.add('selected');

                    // Update melodyContext
                    melodyContext = this.getAttribute('data-context');

                    // Update the adjustment info if a key is active and a chord symbol is present
                    const activeKey = document.querySelector('.small-white-key.active, .small-black-key.active');
                    if (activeKey && chordDisplay.textContent) {
                        const note = activeKey.getAttribute('data-note');
                        updateAdjustmentInfo(note, melodyContext);
                    }
                });
            });

            const deselectChordButton = document.querySelector('.deselect-chord-button');
            deselectChordButton.addEventListener('click', function() {

                // Disable context buttons
                document.querySelectorAll('.chord-btn').forEach(button => {
                    button.classList.remove('selected');
                    button.classList.remove('disabled');
                });

                contextButtons.forEach(button => {
                    button.classList.add('disabled');
                    button.classList.remove('selected');
                });

                chordDisplay.textContent = '';
                chordPitches.textContent = '';
                adjustmentInfo.textContent = '';
            });

            // Modify your existing updateAdjustmentInfo function
            function updateAdjustmentInfo(pitchInfo, melodyContext) {
                try {
                    const [adjustmentData, insideData, outsideData] = intonate_single_pitch(pitchInfo, chordPitchesList, melodyContext);
                    adjustmentInfo.textContent = adjustmentData;
                    insidePossible = insideData;
                    outsidePossible = outsideData;
                } catch (error) {
                    console.error('Error:', error);
                }

                // Update the state of the context-buttons
                const insideButton = document.querySelector('.context-button[data-context="inside"]');
                const outsideButton = document.querySelector('.context-button[data-context="outside"]');
                const insideButtonSelected = insideButton.classList.contains('selected');
                const outsideButtonSelected = outsideButton.classList.contains('selected');

                if (insidePossible && outsidePossible) {
                    insideButton.classList.remove('disabled');
                    outsideButton.classList.remove('disabled');
                    if (insideButtonSelected) {
                        insideButton.classList.add('selected');
                        melodyContext = "inside";
                        outsideButton.classList.remove('selected');
                    } else if (outsideButtonSelected) {
                        outsideButton.classList.add('selected');
                        melodyContext = "outside";
                        insideButton.classList.remove('selected');
                    } else {
                        insideButton.classList.add('selected');
                        melodyContext = "inside";
                        outsideButton.classList.remove('selected');
                    }
                } else if (insidePossible && !outsidePossible) {
                    insideButton.classList.remove('disabled');
                    outsideButton.classList.add('disabled');
                    insideButton.classList.add('selected');
                    melodyContext = "inside";
                    outsideButton.classList.remove('selected');
                } else {
                    outsideButton.classList.remove('disabled');
                    insideButton.classList.add('disabled');
                    outsideButton.classList.add('selected');
                    melodyContext = "outside";
                    insideButton.classList.remove('selected');
                }
            }

            function updateChordSymbol() {
                const components = [
                    selectedRoot,
                    selectedQuality,
                    selectedSeventh,
                    selectedExtension,
                    selectedAlteration,
                    selectedSlash
                ];
                
                if (selectedRoot && selectedQuality) {
                    try {
                        const chordSymbol = construct_chord_symbol(components);
                        const [chordPitchesString, pitchList, updatedChordSymbol] = pitches_from_chord_symbol(chordSymbol);
                        chordDisplay.textContent = updatedChordSymbol;
                        chordPitches.textContent = chordPitchesString;
                        chordPitchesList = pitchList;
                    } catch (error) {
                        console.error('Error:', error);
                    }
                } else {
                    chordDisplay.textContent = '';
                    chordPitches.textContent = '';
                }
            }
        
            function updateAvailableOptions() {
                const components = [
                    selectedRoot,
                    selectedQuality,
                    selectedSeventh,
                    selectedExtension,
                    selectedAlteration,
                    selectedSlash
                ];

                try {
                    const availableOptionsData = get_available_options(components);
                    const availableOptions = availableOptionsData;

                // Gray out unavailable options
                document.querySelectorAll(`[data-type="quality"]`).forEach(btn => {
                    const qualitiesArray = availableOptions['qualities'];
                    if (!qualitiesArray.includes(btn.dataset.value)) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                });

                document.querySelectorAll(`[data-type="seventh"]`).forEach(btn => {
                    const extensionsArray = availableOptions['sevenths'];
                    if (!extensionsArray.includes(btn.dataset.value)) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                });

                document.querySelectorAll(`[data-type="extension"]`).forEach(btn => {
                    const extensionsArray = availableOptions['extensions'];
                    if (!extensionsArray.includes(btn.dataset.value)) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                });

                document.querySelectorAll(`[data-type="alteration"]`).forEach(btn => {
                    const alterationsArray = availableOptions['alterations'];
                    if (!alterationsArray.includes(btn.dataset.value)) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                });

                document.querySelectorAll(`[data-type="slash-root"]`).forEach(btn => {
                    const slashesArray = availableOptions['slashes'];
                    if (!slashesArray.includes(btn.dataset.value)) {
                        btn.classList.add('disabled');
                    } else {
                        btn.classList.remove('disabled');
                    }
                });
                } catch (error) {
                    console.error('Error:', error);
                }
            }

            function clearXYscreen() {
                // Disable context buttons
                document.querySelectorAll('.chord-btn').forEach(button => {
                    button.classList.remove('selected');
                    button.classList.remove('disabled');
                });

                // Check if contextButtons is defined (it might not be on first load)
                if (typeof contextButtons !== 'undefined' && contextButtons) {
                    contextButtons.forEach(button => {
                        button.classList.add('disabled');
                        button.classList.remove('selected');
                    });
                }

                document.querySelectorAll('.small-white-key, .small-black-key').forEach(key => {
                    key.classList.remove('active');
                });

                // Check if these elements exist before accessing them
                if (typeof adjustmentInfo !== 'undefined' && adjustmentInfo) {
                    adjustmentInfo.textContent = "";
                }
                if (typeof chordDisplay !== 'undefined' && chordDisplay) {
                    chordDisplay.textContent = "";
                }
                if (typeof chordPitches !== 'undefined' && chordPitches) {
                    chordPitches.textContent = "";
                }
                if (typeof melodyContext !== 'undefined') {
                    melodyContext = "inside";
                }
                if (typeof insidePossible !== 'undefined') {
                    insidePossible = true;
                }
                if (typeof outsidePossible !== 'undefined') {
                    outsidePossible = true;
                }
                if (typeof chordPitchesList !== 'undefined') {
                    chordPitchesList = [];
                }
            }

            // Call these functions whenever a button is clicked
            document.querySelectorAll('.chord-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    // Check if the button already has the 'selected' class
                    if (btn.classList.contains('selected')) {
                        // If it does, remove the 'selected' class
                        btn.classList.remove('selected');
                    } else {
                        // If it doesn't, add the 'selected' class to the button
                        btn.classList.add('selected');

                        // Remove the 'selected' class from other buttons in the same group
                        const btnType = btn.getAttribute('data-type');
                        document.querySelectorAll(`[data-type="${btnType}"].selected`).forEach(otherBtn => {
                            if (otherBtn !== btn) {
                                otherBtn.classList.remove('selected');
                            }
                        });
                    }

                    // Update the variables with the current values before calling the functions
                    selectedRoot = document.querySelector('.row.roots .chord-btn.selected') ? document.querySelector('.row.roots .chord-btn.selected').dataset.value : '';
                    selectedQuality = document.querySelector('.row.qualities .chord-btn.selected') ? document.querySelector('.row.qualities .chord-btn.selected').dataset.value : ''; // Changed .value to .dataset.value
                    selectedSeventh = document.querySelector('.row.sevenths .chord-btn.selected') ? document.querySelector('.row.sevenths .chord-btn.selected').dataset.value : ''; // Changed .value to .dataset.value
                    selectedExtension = document.querySelector('.row.extensions .chord-btn.selected') ? document.querySelector('.row.extensions .chord-btn.selected').dataset.value : ''; // Changed .value to .dataset.value
                    selectedAlteration = document.querySelector('.row.alterations .chord-btn.selected') ? document.querySelector('.row.alterations .chord-btn.selected').dataset.value : ''; // Changed .value to .dataset.value
                    
                    if (selectedQuality === "major" && selectedSeventh === "m7") {
                        document.querySelector('button.chord-btn[data-type="quality"][data-value="major"]').textContent = "Dominant";
                    } else {
                        document.querySelector('button.chord-btn[data-type="quality"][data-value="major"]').textContent = "Major";
                    }

                    if (selectedRoot.includes("#") && ["major", "augmented", "sus2", "sus4"].includes(selectedQuality)) {
                        // Select all buttons with data-type="slash-root" and data-value containing a sharp (#)
                        const slashRootButtons = document.querySelectorAll('button.chord-btn[data-type="slash-root"][data-value*="#"]');
                        // Loop through each button to update its text content
                        slashRootButtons.forEach(button => {
                            const originalValue = button.dataset.value.split('/')[1];
                            const enharmonicValue = enharmonicMap[originalValue] || originalValue; // Use the mapped value if it exists
                            button.textContent = '/' + enharmonicValue;
                        });
                    } else {
                        // Reset to original state if needed
                        const slashRootButtons = document.querySelectorAll('button.chord-btn[data-type="slash-root"][data-value*="#"]');
                        
                        // Loop through each button to update its text content
                        slashRootButtons.forEach(button => {
                            const originalValue = button.dataset.value.split('/')[1];
                            const enharmonicValue = reverseEnharmonicMap[originalValue] || originalValue; // Use the mapped value if it exists
                            button.textContent = '/' + enharmonicValue;
                        });
                    }

                    selectedSlash = document.querySelector('.row.slash-roots .chord-btn.selected') ? document.querySelector('.row.slash-roots .chord-btn.selected').textContent : ''; // Changed .value to .dataset.value
                    const enharmonicRoot = enharmonicMap[selectedRoot] || selectedRoot; // Use the mapped value if it exists
                    if (selectedSlash.split("/")[1] === enharmonicRoot || selectedSlash.split("/")[1] === selectedRoot) {
                        selectedSlash = "";
                    }

                    // Call the functions
                    updateAvailableOptions();

                    // New code to check for disabled class
                    ['.row.roots', '.row.qualities', '.row.sevenths', '.row.extensions', '.row.alterations'].forEach(selector => {
                        const selectedButton = document.querySelector(`${selector} .chord-btn.selected`);
                        if (selectedButton && selectedButton.classList.contains('disabled')) {

                            // Remove the 'selected' class
                            selectedButton.classList.remove('selected');

                            switch (selector) {
                                case '.row.roots':
                                    selectedRoot = '';
                                    break;
                                case '.row.qualities':
                                    selectedQuality = '';
                                    break;
                                case '.row.sevenths':
                                    selectedSeventh = '';
                                    break;
                                case '.row.extensions':
                                    selectedExtension = '';
                                    break;
                                case '.row.alterations':
                                    selectedAlteration = '';
                                    break;
                            }
                        }
                    });

                    updateChordSymbol();

                    // Update the adjustment info if a key is active
                    const activeKey = document.querySelector('.small-white-key.active, .small-black-key.active');
                    if (activeKey && (selectedRoot && selectedQuality)) {
                        const note = activeKey.getAttribute('data-note');
                        updateAdjustmentInfo(note, melodyContext);
                    } else {
                        adjustmentInfo.textContent = "";
                        contextButtons.forEach(button => {
                            button.classList.add('disabled');
                            button.classList.remove('selected');});
                    }
                });
            });

            //// Phase Tab Functionality /////
            const dragLines = document.querySelectorAll('.phase-drag-line');
            let dragItems = document.querySelectorAll('.note-drag');
            let presetCents = [0, 702]
            let active = false;
            let yDelta;
            let initialY;
            let lastClientY = null;
            let yOffset = 0;
            let draggedItem;
            let linePositions = [];
            let svgPositions = [];
            let frequencyFactors = [];
            let phaseChordLabel = document.querySelector('.phase-chord-type-label');
            let phaseNoteNumber = document.querySelectorAll('.note-drag:not(.hidden)').length;
            let phaseChordNumberDisplay = document.querySelector('.phase-chord-number-display');
            var sineGraphWidth = 1280;
            var sineGraphHeight = 175;
            var sineGraphScale = 1;
            var sineBaseFrequency = 20;
            var sineBaseSpeed = 0;
            let sineTwoMultiplier;
            let sineThreeMultiplier;
            let sineFourMultiplier;
            let baseColor = "hsl(240, 100%, 50%)";
            let netAmplitude;
            let allSineFrequencies = [];
            let allSineAmplitudes = [];
            let allSinePhaseShifts = [];
            sineGraphStart();

            // Function to update button visibility based on note number
            function updateNoteNumberButtons(number) {
                const minusButton = document.querySelector('.chord-number-button[data-type="minus"]');
                const plusButton = document.querySelector('.chord-number-button[data-type="plus"]');
                
                if (minusButton && plusButton) {
                    if (number === 2) {
                        // 2 notes: hide minus button but keep its space
                        minusButton.style.visibility = 'hidden';
                        minusButton.style.pointerEvents = 'none';
                        plusButton.style.visibility = 'visible';
                        plusButton.style.pointerEvents = 'auto';
                    } else if (number === 3) {
                        // 3 notes: show both buttons
                        minusButton.style.visibility = 'visible';
                        minusButton.style.pointerEvents = 'auto';
                        plusButton.style.visibility = 'visible';
                        plusButton.style.pointerEvents = 'auto';
                    } else if (number === 4) {
                        // 4 notes: hide plus button but keep its space
                        minusButton.style.visibility = 'visible';
                        minusButton.style.pointerEvents = 'auto';
                        plusButton.style.visibility = 'hidden';
                        plusButton.style.pointerEvents = 'none';
                    }
                }
            }

            // Initialize button visibility on page load
            updateNoteNumberButtons(phaseNoteNumber);

            const phaseTabPlusMinus = document.querySelectorAll('.chord-number-button');
            phaseTabPlusMinus.forEach(button => {
                button.addEventListener('click', function() {
                    const buttonDataType = button.getAttribute('data-type');

                    if (phaseNoteNumber === 2 && buttonDataType === "minus" || phaseNoteNumber === 4 && buttonDataType === "plus") {
                        return;
                    } else if (buttonDataType === "plus") {
                        const hiddenNote = document.querySelector('.note-drag.hidden');
                        if (hiddenNote) {
                            hiddenNote.classList.remove('hidden');
                        }
                        phaseNoteNumber += 1;
                        if (phaseChordNumberDisplay) {
                            phaseChordNumberDisplay.textContent = phaseNoteNumber;
                        }
                    } else if (buttonDataType === "minus") {
                        const noteDrags = document.querySelectorAll('.note-drag');
                        if (noteDrags[phaseNoteNumber - 1]) {
                            noteDrags[phaseNoteNumber - 1].classList.add('hidden');
                        }
                        phaseNoteNumber -= 1;
                        if (phaseChordNumberDisplay) {
                            phaseChordNumberDisplay.textContent = phaseNoteNumber;
                        }
                    }

                    // Update button visibility after number change
                    updateNoteNumberButtons(phaseNoteNumber);

                    if (phaseChordLabel) {
                        if (phaseNoteNumber === 2) {
                            phaseChordLabel.textContent = "Interval";
                        } else {
                            phaseChordLabel.textContent = "Chord Quality";
                        }
                    }
                    updatePresets(phaseNoteNumber);
                });
            });

            function updatePresets (number) {
                let activeGroup;
                if (number === 2) {
                    activeGroup = document.querySelector('.phase-chord-intervals');
                    document.querySelector('.phase-chord-intervals').querySelector('.phase-chord-preset[data-type="P5"]').classList.add('active');
                    activeGroup.classList.remove('hidden');
                    document.querySelector('.phase-chord-triads').classList.add('hidden');
                    document.querySelector('.phase-chord-sevenths').classList.add('hidden');
                } else if (number === 3) {
                    activeGroup = document.querySelector('.phase-chord-triads');
                    document.querySelector('.phase-chord-triads').querySelector('.phase-chord-preset[data-type="major"]').classList.add('active');
                    document.querySelector('.phase-chord-intervals').classList.add('hidden');
                    document.querySelector('.phase-chord-sevenths').classList.add('hidden');
                    activeGroup.classList.remove('hidden');
                } else if (number === 4) {
                    activeGroup = document.querySelector('.phase-chord-sevenths');
                    document.querySelector('.phase-chord-sevenths').querySelector('.phase-chord-preset[data-type="major 7th"]').classList.add('active');
                    document.querySelector('.phase-chord-intervals').classList.add('hidden');
                    document.querySelector('.phase-chord-triads').classList.add('hidden');
                    activeGroup.classList.remove('hidden');
                }
                // set group defaults

                const activePreset = activeGroup.querySelector('.phase-chord-preset.active')
                const presetData = activePreset.getAttribute('data-type');
                presetCents = getPresetCents(presetData);
                calculateLinePositions();
                setAllPositionsFromValues(presetCents);
                getAllPositionValues();
                try {
                        if (presetData.length === 2) {
                            var intervalRatio = interval_just_ratio_dict[presetData];
                        getFrequencyFactors(intervalRatio);
                        setRatioDisplay(intervalRatio);
                    } else {
                            var intervalRatios = centsListToChordRatios(svgPositions);
                        getFrequencyFactors(intervalRatios);
                        setRatioDisplay(intervalRatios);
                    }
                } catch (error) {
                    console.error('Error:', error);
                }
                var cancellations = calculatePhaseCancellation(allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                setCancellationDisplay(cancellations)
            }

            const phaseTabPresets = document.querySelectorAll('.phase-chord-preset');

            phaseTabPresets.forEach(preset => {
                preset.addEventListener('click', function() {
                    if (!preset.parentElement.classList.contains('hidden')) {
                        const presetParentChildren = preset.parentElement.querySelectorAll('.phase-chord-preset');
                        presetParentChildren.forEach(preset => {
                            preset.classList.remove('active');
                        });
                    }
                    preset.classList.add('active');

                    const presetData = preset.getAttribute('data-type');
                    presetCents = getPresetCents(presetData);
                    calculateLinePositions();
                    setAllPositionsFromValues(presetCents);
                    getAllPositionValues();
                    try {
                        if (presetData.length === 2) {
                            var intervalRatio = interval_just_ratio_dict[presetData];
                            getFrequencyFactors(intervalRatio);
                            setRatioDisplay(intervalRatio);
                            var cancellations = calculatePhaseCancellation(allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                            setCancellationDisplay(cancellations)
                        } else {
                            var intervalRatios = centsListToChordRatios(svgPositions);
                            getFrequencyFactors(intervalRatios);
                            setRatioDisplay(intervalRatios);
                        }
                        var cancellations = calculatePhaseCancellation(allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                        setCancellationDisplay(cancellations)
                    } catch (error) {
                        console.error('Error:', error);
                    }
                });
            });

            function calculateLinePositions() {
                try {
                    linePositions = []; // Reset the array
                    if (!dragLines || dragLines.length === 0) {
                        return;
                    }
                    dragLines.forEach(line => {
                        if (line) {
                            const rect = line.getBoundingClientRect();
                            const centerY = ((rect.top + rect.bottom) / 2) + window.scrollY;
                            if (!isNaN(centerY)) {
                                linePositions.push(centerY); // Adjust for scrolling
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error in calculateLinePositions:', error);
                    linePositions = [];
                }
            }
            
            function storeOriginalPositions() {
                try {
                    if (!dragItems || dragItems.length === 0) {
                        return;
                    }
                    dragItems.forEach(item => {
                        if (item) {
                            const rect = item.getBoundingClientRect();
                            const originalCenterY = rect.top + window.scrollY + rect.height / 2;
                            if (!isNaN(originalCenterY)) {
                                // Store the original center Y position as a data attribute
                                item.dataset.originalCenterY = originalCenterY.toString();
                            }
                        }
                    });
                } catch (error) {
                    console.error('Error in storeOriginalPositions:', error);
                }
            }

            function getAllPositionValues() {
                try {
                    svgPositions = []; // Reset the array
                    calculateLinePositions();
                    if (!dragItems || dragItems.length === 0) {
                        return;
                    }
                    
                    // Sort drag items by ID to ensure consistent order (note-drag-1, note-drag-2, etc.)
                    const sortedDragItems = Array.from(dragItems).sort((a, b) => {
                        const aNum = parseInt(a.id.match(/\d+/)?.[0] || '0');
                        const bNum = parseInt(b.id.match(/\d+/)?.[0] || '0');
                        return aNum - bNum;
                    });
                    
                    // Collect positions in order, ensuring note-drag-1 is always first and at 0
                    sortedDragItems.forEach(item => {
                        if (!item.classList.contains('hidden')) {
                            if (item.id === 'note-drag-1') {
                                // note-drag-1 is always the reference note at 0 cents
                                svgPositions.push(0);
                            } else {
                                const value = getValueFromPosition(item);
                                svgPositions.push(value);
                            }
                        }
                    });
                    
                    // Ensure the first element is always 0 (base/reference note)
                    // If we have positions but first isn't 0, fix it
                    if (svgPositions.length > 0 && svgPositions[0] !== 0) {
                        // Find note-drag-1's position if it exists
                        const noteDrag1Index = sortedDragItems.findIndex(item => item.id === 'note-drag-1' && !item.classList.contains('hidden'));
                        if (noteDrag1Index >= 0 && noteDrag1Index < svgPositions.length) {
                            // Swap: move note-drag-1's value (should be 0) to first position
                            const temp = svgPositions[0];
                            svgPositions[0] = 0; // note-drag-1 is always 0
                            if (noteDrag1Index > 0) {
                                svgPositions[noteDrag1Index] = temp;
                            }
                        } else {
                            // If note-drag-1 is not in the list, ensure first is 0
                            svgPositions.unshift(0);
                        }
                    }
                } catch (error) {
                    console.error('Error in getAllPositionValues:', error);
                    svgPositions = [];
                }
            }

            function getValueFromPosition(svgElement) {
                try {
                    if (!svgElement || !linePositions || linePositions.length < 2) {
                        return "Out of range";
                    }
                    
                    const svgRect = svgElement.getBoundingClientRect();
                    const svgCenterY = svgRect.top + window.scrollY + svgRect.height / 2;

                    for (let i = 0; i < linePositions.length - 1; i++) {
                        if (!dragLines[i + 1]) {
                            continue;
                        }
                        
                        const centLineValue = Number(dragLines[i + 1].getAttribute('data-type'));
                        if (isNaN(centLineValue)) {
                            continue;
                        }
                        
                        if (svgCenterY >= linePositions[i] && svgCenterY <= linePositions[i + 1]) {
                            const range = linePositions[i + 1] - linePositions[i];
                            if (range === 0) {
                                // If range is 0, return the cent line value directly
                                return Math.round(centLineValue, 0);
                            }
                            const relativePos = linePositions[i + 1] - svgCenterY;
                            const centPercent = relativePos / range;
                            const interpolatedValue = (centPercent * 100) + centLineValue;
                            return Math.round(interpolatedValue, 0);
                        }
                    }
                    return "Out of range"; // If the SVG is not between any lines
                } catch (error) {
                    console.error('Error in getValueFromPosition:', error);
                    return "Out of range";
                }
            }

            function setAllPositionsFromValues(values) {
                calculateLinePositions();
                dragItems.forEach((item, index) => {
                    if (!item.classList.contains('hidden')) {
                        setPositionFromValue(item, values[index]);
                    }
                });
            }

            function setPositionFromValue(svgElement, value) {
                try {
                    if (!svgElement || typeof value !== 'number' || isNaN(value)) {
                        return;
                    }
                    
                    const originalCenterY = parseFloat(svgElement.dataset.originalCenterY);
                    if (isNaN(originalCenterY)) {
                        // If originalCenterY is not set, calculate it from current position
                        const rect = svgElement.getBoundingClientRect();
                        svgElement.dataset.originalCenterY = (rect.top + window.scrollY + rect.height / 2).toString();
                        return; // Try again next time
                    }

                    if (!linePositions || linePositions.length < 2) {
                        return;
                    }

                    for (let i = 0; i < linePositions.length - 1; i++) {
                        if (!dragLines[i + 1] || !dragLines[i]) {
                            continue;
                        }
                        
                        const centLineValue = Number(dragLines[i + 1].getAttribute('data-type'));
                        const nextCentLineValue = Number(dragLines[i].getAttribute('data-type'));
                        
                        if (isNaN(centLineValue) || isNaN(nextCentLineValue)) {
                            continue;
                        }
                        
                        if (value >= centLineValue && value <= nextCentLineValue) {
                            const range = linePositions[i + 1] - linePositions[i];
                            if (range === 0) {
                                continue; // Skip if range is 0
                            }
                            const centPercent = (value - centLineValue) / 100;
                            const relativePos = range * centPercent;
                            const newY = linePositions[i + 1] - relativePos;
                            const translationY = newY - originalCenterY;
                            if (!isNaN(translationY)) {
                                svgElement.style.transform = `translate3d(0, ${translationY}px, 0)`;
                            }
                            break; // Exit the loop once the correct position is found and applied
                        }
                    }
                } catch (error) {
                    console.error('Error in setPositionFromValue:', error);
                }
            }

            function getPresetCents(presetType) {
                try {
                    return quality_or_interval_to_chord_tones_cents(presetType);
                } catch (error) {
                    console.error('Error:', error);
                    return [];
                }
            }

            function centsListToChordRatios(centsList, denom = 10) {
                try {
                    if (!centsList || !Array.isArray(centsList) || centsList.length === 0) {
                        return [];
                    }
                    
                    // Filter out "Out of range" strings and invalid values, but preserve order
                    // The first element must be 0 (base note), so we need to handle this carefully
                    const validCents = [];
                    let hasBaseNote = false;
                    
                    for (let i = 0; i < centsList.length; i++) {
                        const val = centsList[i];
                        if (typeof val === 'number' && !isNaN(val) && val !== "Out of range") {
                            // If this is the first element and it's not 0, we need to ensure base is 0
                            if (i === 0 && val !== 0) {
                                // Insert 0 at the beginning if first element is not 0
                                validCents.push(0);
                                hasBaseNote = true;
                                // Continue to include this value if it's valid
                                if (val !== 0) {
                                    validCents.push(val);
                                }
                            } else {
                                // For subsequent elements, just add them
                                if (i === 0) {
                                    hasBaseNote = true;
                                }
                                validCents.push(val);
                            }
                        }
                    }
                    
                    // Ensure first element is always 0 (base note)
                    if (validCents.length > 0 && validCents[0] !== 0) {
                        validCents.unshift(0);
                    }
                    
                    if (validCents.length === 0 || validCents[0] !== 0) {
                        return [];
                    }
                    
                    return cents_list_to_chord_ratios(validCents, denom);
                } catch (error) {
                    console.error('Error in centsListToChordRatios:', error);
                    return [];
                }
            }

            function setRatioDisplay(ratios) {
                try {
                    const ratioDisplay = document.querySelector('.ratio-display');
                    if (ratioDisplay) {
                        if (!ratios || !Array.isArray(ratios) || ratios.length === 0) {
                            ratioDisplay.textContent = '';
                            return;
                        }
                        // format ratio array to like 4:5:6, etc/
                        ratioDisplay.textContent = ratios.join(':');
                    }
                } catch (error) {
                    console.error('Error in setRatioDisplay:', error);
                }
            }

            function setCancellationDisplay(cancellations) {
                try {
                    const cancellationDisplay = document.querySelector('.cancellation-display');
                    if (cancellationDisplay) {
                        const value = (typeof cancellations === 'number' && !isNaN(cancellations)) ? cancellations : 0;
                        cancellationDisplay.textContent = value + "/s";
                    }
                } catch (error) {
                    console.error('Error in setCancellationDisplay:', error);
                }
            }

            function getFrequencyFactors(intervalRatios) {
                try {
                    if (!intervalRatios || !Array.isArray(intervalRatios) || intervalRatios.length === 0) {
                        frequencyFactors = [];
                        allSineFrequencies = [sineBaseFrequency];
                        allSineAmplitudes = [50];
                        allSinePhaseShifts = [0];
                        return;
                    }
                    
                    frequencyFactors = [];
                    var frequencyList = [1];
                    for (let i = 0; i < intervalRatios.length - 1; i++) {
                        if (typeof intervalRatios[i] !== 'number' || typeof intervalRatios[i + 1] !== 'number') {
                            continue;
                        }
                        if (intervalRatios[i] === 0) {
                            console.warn('Division by zero in getFrequencyFactors');
                            continue;
                        }
                        frequencyList.push(intervalRatios[i + 1] / intervalRatios[i]);
                    }
                    frequencyFactors = frequencyList;
                    assignSineMultipliers();
                    
                    if (sineThreeMultiplier === 0 && sineFourMultiplier === 0) {
                        allSineFrequencies = [sineBaseFrequency, sineBaseFrequency * sineTwoMultiplier];
                        allSineAmplitudes = [50, 50];
                        allSinePhaseShifts = [0, sineBaseSpeed * sineTwoMultiplier];
                    } else if (sineFourMultiplier === 0) {
                        allSineFrequencies = [sineBaseFrequency, sineBaseFrequency * sineTwoMultiplier, sineBaseFrequency * sineThreeMultiplier];
                        allSineAmplitudes = [50, 50, 50];
                        allSinePhaseShifts = [0, sineBaseSpeed * sineTwoMultiplier, sineBaseSpeed * sineThreeMultiplier];
                    } else {
                        allSineFrequencies = [sineBaseFrequency, sineBaseFrequency * sineTwoMultiplier, sineBaseFrequency * sineThreeMultiplier, sineBaseFrequency * sineFourMultiplier];
                        allSineAmplitudes = [50, 50, 50, 50];
                        allSinePhaseShifts = [0, sineBaseSpeed * sineTwoMultiplier, sineBaseSpeed * sineThreeMultiplier, sineBaseSpeed * sineFourMultiplier];
                    }
                } catch (error) {
                    console.error('Error in getFrequencyFactors:', error);
                    frequencyFactors = [];
                    allSineFrequencies = [sineBaseFrequency];
                    allSineAmplitudes = [50];
                    allSinePhaseShifts = [0];
                }
            }
            
            function assignSineMultipliers() {
                if (frequencyFactors.length === 0) {
                    sineTwoMultiplier = 1;
                    sineThreeMultiplier = 1;
                    sineFourMultiplier = 1;
                } else if (frequencyFactors.length === 2) {
                    sineTwoMultiplier = frequencyFactors[1];
                    sineThreeMultiplier = 0;
                    sineFourMultiplier = 0;
                } else if (frequencyFactors.length === 3) {
                    sineTwoMultiplier = frequencyFactors[1];
                    sineThreeMultiplier = frequencyFactors[2];
                    sineFourMultiplier = 0;
                } else if (frequencyFactors.length === 4) {
                    sineTwoMultiplier = frequencyFactors[1];
                    sineThreeMultiplier = frequencyFactors[2];
                    sineFourMultiplier = frequencyFactors[3];
                } 
            }

            function dragStart(e) {
                // Find the note-drag element (in case e.target is a child element)
                let target = e.target;
                if (!target.classList.contains('note-drag')) {
                    target = target.closest('.note-drag');
                }
                
                if (target && target.classList.contains('note-drag')) {
                    e.preventDefault();
                    e.stopPropagation();
                    
                    // Handle both mouse and touch events
                    if (e.type === 'touchstart') {
                        initialY = e.touches[0].clientY;
                    } else {
                        initialY = e.clientY;
                    }
                    active = true;
                    draggedItem = target;

                    // Ensure originalCenterY is set
                    if (!draggedItem.dataset.originalCenterY || isNaN(parseFloat(draggedItem.dataset.originalCenterY))) {
                        const rect = draggedItem.getBoundingClientRect();
                        const currentCenterY = rect.top + window.scrollY + rect.height / 2;
                        draggedItem.dataset.originalCenterY = currentCenterY.toString();
                    }

                    // If the element has a previous translation, store it; otherwise, start at 0
                    const transform = draggedItem.style.transform;
                    if (transform && transform !== 'none') {
                        // Parse translate3d(0, yOffset, 0) - handle various formats
                        // Match pattern: translate3d(X, Y, Z) where Y may have units like "px"
                        const match = transform.match(/translate3d\([^,]+,\s*([^,)]+)/);
                        if (match) {
                            // parseFloat handles units like "px" correctly (returns 50 for "50px")
                            yOffset = parseFloat(match[1].trim());
                        } else {
                            // Fallback: try to parse translateY
                            const translateYMatch = transform.match(/translateY\(([^)]+)\)/);
                            if (translateYMatch) {
                                yOffset = parseFloat(translateYMatch[1].trim());
                            } else {
                                yOffset = 0;
                            }
                        }
                    } else {
                        yOffset = 0;
                    }
                }
            }

            function drag(e) {
                if (active && draggedItem) {
                    try {
                        e.preventDefault();
                        e.stopPropagation();
                        
                        // Handle both mouse and touch events
                        let currentY;
                        if (e.type === 'touchmove') {
                            if (e.touches.length > 0) {
                                currentY = e.touches[0].clientY;
                            } else {
                                return; // No touch data available
                            }
                        } else {
                            currentY = e.clientY;
                        }
                        
                        if (typeof initialY !== 'number' || isNaN(initialY)) {
                            return; // Invalid initialY
                        }
                        
                        yDelta = currentY - initialY;
                        let newYOffset = yOffset + yDelta;
                        
                        // Calculate boundaries based on drag lines
                        if (!linePositions || linePositions.length < 2) {
                            calculateLinePositions();
                        }
                        
                        if (linePositions.length >= 2) {
                            // Get the original position of the dragged item
                            const originalCenterY = parseFloat(draggedItem.dataset.originalCenterY);
                            if (!isNaN(originalCenterY)) {
                                // Calculate boundaries: min is the first line (top), max is the last line (bottom)
                                const minLineY = linePositions[0]; // First line (top)
                                const maxLineY = linePositions[linePositions.length - 1]; // Last line (bottom)
                                
                                // Calculate the min and max offsets based on boundaries
                                // The note's center should stay between minLineY and maxLineY
                                const minOffset = minLineY - originalCenterY;
                                const maxOffset = maxLineY - originalCenterY;
                                
                                // Constrain newYOffset to stay within boundaries
                                newYOffset = Math.max(minOffset, Math.min(maxOffset, newYOffset));
                            }
                        }
                        
                        // Apply the transform immediately for smooth dragging
                        setTranslate(0, newYOffset, draggedItem);
                        
                        // Update positions and calculations
                        getAllPositionValues();
                        var intervalRatios = centsListToChordRatios(svgPositions, 100);
                        setRatioDisplay(intervalRatios);
                        getFrequencyFactors(intervalRatios);
                        var cancellations = calculatePhaseCancellation(allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                        setCancellationDisplay(cancellations);
                        
                        // Remove active preset when manually dragging
                        const activePreset = document.querySelector('.phase-chord-preset.active');
                        if (activePreset) {
                            activePreset.classList.remove('active');
                        }
                    } catch (error) {
                        console.error('Error in drag:', error);
                        // Reset drag state on error
                        active = false;
                        draggedItem = null;
                    }
                }
            }

            function dragEnd(e) {
                if (active && draggedItem) {
                    try {
                        // Update yOffset to the final position so subsequent drags start from correct position
                        const transform = draggedItem.style.transform;
                        if (transform && transform !== 'none') {
                            const match = transform.match(/translate3d\([^,]+,\s*([^,)]+)/);
                            if (match) {
                                const parsedOffset = parseFloat(match[1].trim());
                                if (!isNaN(parsedOffset)) {
                                    yOffset = parsedOffset;
                                }
                            }
                        }
                        
                        getAllPositionValues();
                        var intervalRatios = centsListToChordRatios(svgPositions, 100);
                        setRatioDisplay(intervalRatios);
                        getFrequencyFactors(intervalRatios);
                        var cancellations = calculatePhaseCancellation(allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                        setCancellationDisplay(cancellations);
                    } catch (error) {
                        console.error('Error in dragEnd:', error);
                    } finally {
                        // Reset drag state
                        active = false;
                        draggedItem = null;
                        initialY = null;
                        yDelta = 0;
                        // Note: yOffset is preserved so subsequent drags continue from current position
                    }
                }
            }

            function setTranslate(xPos, yPos, el) {
                el.style.transform = `translate3d(${xPos}px, ${yPos}px, 0)`;
            }
        
            function showAxes(ctx,axes) {
                var width = ctx.canvas.width;
                var height = ctx.canvas.height;
                var xMin = 0;
                
                ctx.beginPath();
                ctx.strokeStyle = "rgb(128,128,128)";
                
                // X-Axis
                ctx.moveTo(xMin, height/2);
                ctx.lineTo(width, height/2);

                // // Starting line
                // ctx.moveTo(0, 0);
                // ctx.lineTo(0, height);
                
                ctx.stroke();
            }

            function calculateNetAmplitude(x, xOffset, frequencies, amplitudes, phaseShifts) {
                let netAmplitude = 0;
                for (let i = 0; i < frequencies.length; i++) {
                    let y = amplitudes[i] * Math.sin((x + xOffset + phaseShifts[i]) / frequencies[i]);
                    netAmplitude += y;
                }
                return netAmplitude;
            }

            function adjustColorBasedOnAmplitude(color, amplitude) {
                // Parse the HSL color to extract its components
                let [hue, saturation, lightness] = color.match(/\d+/g).map(Number);

                // Adjust the lightness based on the amplitude
                // Example: scale the lightness from 30% to 70% based on the amplitude
                let adjustedLightness = 30 + (amplitude * 20); // Adjust this range as needed

                // Ensure lightness does not exceed 100%
                // adjustedLightness = Math.min(100, adjustedLightness);
                adjustedLightness = lightness;

                // Adjust saturation based on the amplitude
                // Example: scale the saturation from 50% to 100% based on the amplitude
                let adjustedSaturation = 50 + (amplitude * 50); // Adjust this range as needed

                // Ensure saturation does not exceed 100%
                adjustedSaturation = Math.min(100, adjustedSaturation);

                return `hsl(${hue}, ${adjustedSaturation}%, ${adjustedLightness}%)`;
            }

            function adjustStrokeWidthBasedOnAmplitude(amplitude) {
                // Example: scale stroke width from 1 to 5 based on amplitude
                return 2 + (amplitude * 10); // Adjust this range as needed
            }

            function calculatePhaseCancellation(frequencies, amplitudes, phaseShifts) {
                try {
                    if (!frequencies || !amplitudes || !Array.isArray(frequencies) || !Array.isArray(amplitudes) || frequencies.length === 0) {
                        return 0;
                    }
                    
                    // Ensure phaseShifts exists and has the same length
                    if (!phaseShifts || !Array.isArray(phaseShifts) || phaseShifts.length !== frequencies.length) {
                        phaseShifts = new Array(frequencies.length).fill(0);
                    }
                    
                    let dt = 0.001; // Time step
                    let cancellations = 0;
                    let zeroCrossings = 0;
                    let threshold = 2; // Define a suitable threshold for low net amplitude
                    let currentSign = 1;

                    for (let t = 0; t <= 1; t += dt) {
                        let sum = 0;
                        for (let i = 0; i < frequencies.length; i++) {
                            const freq = frequencies[i];
                            const amp = amplitudes[i] || 0;
                            const phaseShift = phaseShifts[i] || 0;
                            
                            // Skip invalid values
                            if (typeof freq !== 'number' || isNaN(freq) || !isFinite(freq) || freq === 0) {
                                continue;
                            }
                            if (typeof amp !== 'number' || isNaN(amp) || !isFinite(amp)) {
                                continue;
                            }
                            
                            sum += amp * Math.sin(2 * Math.PI * freq * t + phaseShift);
                        }
                        const sign = Math.sign(sum);
                        if (sign !== 0 && sign !== currentSign) {
                            zeroCrossings++;
                            currentSign = sign;
                        }
                        if (Math.abs(sum) < threshold) {
                            cancellations++;
                        }
                    }
                    return cancellations;
                } catch (error) {
                    console.error('Error in calculatePhaseCancellation:', error);
                    return 0;
                }
            }

            function plotSine(ctx, xOffset, frequency, baseColor, amplitude = 70) {
                var width = ctx.canvas.width;
                var height = ctx.canvas.height;

                let allSineFrequencies = [sineBaseFrequency, sineBaseFrequency / sineTwoMultiplier, sineBaseFrequency / sineThreeMultiplier, sineBaseFrequency / sineFourMultiplier];
                let allSineAmplitudes = [50, 50, 50, 50]; // Example amplitudes
                let allSinePhaseShifts = [0, sineBaseSpeed * sineTwoMultiplier, sineBaseSpeed * sineThreeMultiplier, sineBaseSpeed * sineFourMultiplier];

                for (let x = 0; x < width; x++) {
                    let netAmplitude = calculateNetAmplitude(x, xOffset, allSineFrequencies, allSineAmplitudes, allSinePhaseShifts);
                    let y = height / 2 + amplitude * Math.sin((x + xOffset) / frequency);
                    let normalizedAmplitude = Math.abs(netAmplitude) / (Math.max(...[amplitude]) * 4); // Normalize net amplitude for color adjustment

                    ctx.strokeStyle = adjustColorBasedOnAmplitude(baseColor, normalizedAmplitude);
                    ctx.lineWidth = adjustStrokeWidthBasedOnAmplitude(normalizedAmplitude);
                    // console.log(`x: ${x}, netAmplitude: ${netAmplitude}, normalizedAmplitude: ${normalizedAmplitude}, lineWidth: ${ctx.lineWidth}, strokeStyle: ${ctx.strokeStyle}`);
                    // Begin a new path for each segment with specific stroke width
                    if (x === 0) {
                        ctx.beginPath();
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                        ctx.stroke(); // Apply stroke here to use the specific lineWidth
                        ctx.beginPath(); // Begin new path to potentially use a new lineWidth
                        ctx.moveTo(x, y);
                    }
                }
                ctx.stroke();
            }

            function draw() {
                var canvas = document.getElementById("canvas");
                var context = canvas.getContext("2d");
                canvas.style.width = sineGraphWidth + 'px';
                canvas.style.height = sineGraphHeight + 'px';
                canvas.width = sineGraphWidth * sineGraphScale;
                canvas.height = sineGraphHeight * sineGraphScale;

                context.clearRect(0, 0, canvas.width, canvas.height);
                showAxes(context);
                context.save();

                var width = context.canvas.width;
                var threshold = 0.01; // Define a suitable threshold for low net amplitude

                plotSine(context, sineBaseSpeed, sineBaseFrequency, baseColor);
                if (sineTwoMultiplier > 0) {
                    plotSine(context, sineBaseSpeed * sineTwoMultiplier, sineBaseFrequency / sineTwoMultiplier, baseColor);
                }
                if (sineThreeMultiplier > 0) {
                    plotSine(context, sineBaseSpeed * sineThreeMultiplier, sineBaseFrequency / sineThreeMultiplier, baseColor);
                }
                if (sineFourMultiplier > 0) {
                    plotSine(context, sineBaseSpeed * sineFourMultiplier, sineBaseFrequency / sineFourMultiplier, baseColor);
                }
                context.restore();
                
                sineBaseSpeed += 2;
                window.requestAnimationFrame(draw);
            }
            
            function sineGraphStart() {
                window.requestAnimationFrame(draw);
            }

            function clearPhaseScreen() {
                try {
                    document.querySelectorAll('.note-drag').forEach(item => {
                        item.style.transform = `translate3d(0, 0, 0)`;
                    });
                    const hiddenNote = document.querySelector('.note-drag.hidden');
                    if (hiddenNote) {
                        hiddenNote.classList.remove('hidden');
                    }
                    if (typeof phaseNoteNumber !== 'undefined') {
                        phaseNoteNumber = 2;
                    }
                    if (typeof phaseChordNumberDisplay !== 'undefined' && phaseChordNumberDisplay) {
                        phaseChordNumberDisplay.textContent = phaseNoteNumber || 2;
                    }
                    if (typeof phaseChordLabel !== 'undefined' && phaseChordLabel) {
                        phaseChordLabel.textContent = "Interval";
                    }
                    if (typeof updatePresets === 'function') {
                        updatePresets(phaseNoteNumber || 2);
                    }
                } catch (error) {
                    console.error('Error in clearPhaseScreen:', error);
                }
            }
        }); // End of window load event listener
    </script>    
</body>
</html>
